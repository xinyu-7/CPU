# CS61CPU

Look ma, I made a CPU! Here's what I did:

- Before we began working on the project, both of us read through the spec together and brainstormed approaches and plans for working together when only one person could be editing the Logisim files at a time. While we both attempted to start Task 1 separately on our own, Xinyu got further and when we met up, explained what she had done thus far, including implementing add, and, or, xor, and sub using the arithmetic blocks and gates. We both worked on understanding how to implement srl, sra, and sll together, and then Anvitha worked on understanding and implementing mul, mulh, and mulhu. We finished Task 1 together on a call. Our design mostly involved subsections for each function using existing blocks (for example, "and" had two inputs going through to an and gate) which was all inputted to a multiplexer, after which ALUSel was used to select which of the functions' output was the desired one. It was fun to bring all of the pieces together!
- For Task 2, we also spent some time re-reading the spec together and understanding what we were supposed to do. While we both knew we had to implement 32 registers and use the register blocks somehow, we weren't entirely sure of an efficient design. After discussing with a TA in office hours and better understanding the purpose of the regfile, we decided to use a demultiplexer to decide which register was the destination register (rd) that needed to be written to and would ensure that the correct register was written to, with write_reg as the selector to tell us what the rd was. After that, we implemented 31 registers for each register in RISC-V, copying and pasting the same register that was first made, each with a clock input and the write data to potentially be written, and the write_enable as the output from the demultiplexer to indicate which the special destination register actually was. Each register also had an associated output which would "read" what was in the register by outputting it at each clock cycle. For the x0 register, we wired it to a constant 0 so it would never change or be written to. Finally, we inputted all of the outputs into two multiplexers with the actual registers we wanted to read as the selectors, which would output the read values. We were both active participants in the design process, and Anvitha worked on implementing the repetitive blocks and making sure the file looked neat in the process.
- In Task 3, we spent a lot of time trying to understand the background, but realized that since we were only implementing addi, a lot of the values could be hardcoded. We had met up several times to discuss approaches, but in the end, Anvitha used a splitter to manually split the instruction into its components and input them into the regfile, placing a register between the instruction and the splitting to pipeline correctly. We followed the diagram from Lectures 18 and 19 to make sure the connections between the ALU were correct, but it was generally quite straightforward and simple to implement, since we knew that an immediate was always being inputted to the ALU to be added. There was hardly any work for this task, but we met up again to recap and make sure that we each had a thorough understanding of what we had done so far in Part A.
- For Part B of the project, Xinyu implemented the branch comparator circuit, where the BrLt and BrUn signals are set by comparing the values of the two registers, and if it is to be an unsigned comparison, a multiplexer selects the correct value. Xinyu also implemented the immediate generator circuit, where she split each instruction and recombined them into each possible immediate, and used the ImmSel signal in a multiplexer to decide the final immediate. Xinyu also started part of the control logic for the CPU.
- After much discussion on how to best implement the control signals, we decided not to simplify to combinational logic and instead decided to use comparators to ensure that control logic would be as easy to debug as possible. Anvitha worked on redesigning what used to be of control logic, and implemented the final output control signals for all of the cases, discussing with Xinyu as she worked. Using charts of all of the control signals for each instruction, compiled using lecture and discussion and extrapolated from there, we tried to simplify the combinational logic to use as few gates as possible and as many splitters as made sense. Our aim was to make our circuit as readable and comprehensible as possible, so that we could understand what was happening at each step visually so it was easuer to identify where something had gone wrong. Anvitha also wired the CPU, including the functionality for loading and storing to memory, based off of discussions and lecture material which took the longest because we did not fully understand how memory worked, and implemented pipelining, with help from office hours. Xinyu implemented the CSR aspect of the CPU, with minor fixes that we both worked on. We both remained checked in with each other during all parts of the project and attended office hours together as often as possible, with each individual focusing on certain bugs to be fixed.
- For the testing aspect of the project, both of us wrote many tests and discussed considerations that we needed to make before writing even more tests. We started by just writing every possibility for each instruction and trying to implement those, and were inspired for more edge cases based on that.
